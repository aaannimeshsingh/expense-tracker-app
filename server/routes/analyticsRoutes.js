// server/routes/analyticsRoutes.js

const express = require('express');
const router = express.Router();
const Expense = require('../models/Expense');
const { protect } = require('../middleware/authMiddleware');

// Simple linear regression for prediction
const predictNextMonth = (monthlyData) => {
  const n = monthlyData.length;
  if (n < 3) return null; // Need at least 3 months of data
  
  let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;
  
  monthlyData.forEach((value, index) => {
    sumX += index;
    sumY += value;
    sumXY += index * value;
    sumX2 += index * index;
  });
  
  const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
  const intercept = (sumY - slope * sumX) / n;
  
  const prediction = slope * n + intercept;
  return Math.max(0, prediction); // Can't have negative spending
};

// server/routes/analyticsRoutes.js
router.post('/insights', protect, async (req, res) => {
  const { expenses, totalByCategory } = req.body;
  
  // Your AI/ML logic here (or call OpenAI API)
  // For now, the frontend has smart client-side fallback
  
  res.json({ insights: 'Generated by AI' });
});

// @route   GET /api/analytics/predictions
// @desc    Get spending predictions for next month
// @access  Private
router.get('/predictions', protect, async (req, res) => {
  try {
    const sixMonthsAgo = new Date();
    sixMonthsAgo.setMonth(sixMonthsAgo.getMonth() - 6);
    
    const expenses = await Expense.find({
      user: req.user._id,
      date: { $gte: sixMonthsAgo }
    }).sort({ date: 1 });
    
    if (expenses.length === 0) {
      return res.json({
        message: 'Not enough data for predictions. Add more expenses!',
        nextMonthPrediction: null,
        dataPoints: 0
      });
    }
    
    // Group by month
    const monthlyTotals = {};
    expenses.forEach(exp => {
      const monthKey = new Date(exp.date).toISOString().substring(0, 7);
      monthlyTotals[monthKey] = (monthlyTotals[monthKey] || 0) + exp.amount;
    });
    
    const values = Object.values(monthlyTotals);
    
    if (values.length < 3) {
      return res.json({
        message: 'Need at least 3 months of data for accurate predictions',
        nextMonthPrediction: null,
        dataPoints: values.length,
        historicalData: monthlyTotals
      });
    }
    
    const prediction = predictNextMonth(values);
    
    // Category-wise predictions
    const categories = [...new Set(expenses.map(e => e.category))];
    const categoryPredictions = {};
    
    categories.forEach(cat => {
      const catExpenses = expenses.filter(e => e.category === cat);
      const catMonthly = {};
      catExpenses.forEach(exp => {
        const monthKey = new Date(exp.date).toISOString().substring(0, 7);
        catMonthly[monthKey] = (catMonthly[monthKey] || 0) + exp.amount;
      });
      const catValues = Object.values(catMonthly);
      if (catValues.length >= 3) {
        categoryPredictions[cat] = predictNextMonth(catValues) || 0;
      }
    });
    
    // Calculate trend
    const recentAvg = values.slice(-3).reduce((a, b) => a + b, 0) / 3;
    const olderAvg = values.slice(0, Math.min(3, values.length)).reduce((a, b) => a + b, 0) / Math.min(3, values.length);
    const trend = recentAvg > olderAvg ? 'increasing' : 'decreasing';
    const trendPercentage = olderAvg > 0 ? ((recentAvg - olderAvg) / olderAvg * 100).toFixed(1) : 0;
    
    // Get next month name
    const nextMonth = new Date();
    nextMonth.setMonth(nextMonth.getMonth() + 1);
    const nextMonthName = nextMonth.toLocaleDateString('en-US', { month: 'long', year: 'numeric' });
    
    res.json({
      nextMonth: nextMonthName,
      nextMonthPrediction: prediction ? parseFloat(prediction.toFixed(2)) : null,
      currentMonthAverage: parseFloat((values[values.length - 1] || 0).toFixed(2)),
      trend,
      trendPercentage: parseFloat(trendPercentage),
      categoryPredictions,
      historicalData: monthlyTotals,
      dataPoints: values.length,
      confidence: values.length >= 6 ? 'high' : values.length >= 4 ? 'medium' : 'low'
    });
  } catch (error) {
    console.error('Error generating predictions:', error);
    res.status(500).json({ 
      message: 'Error generating predictions', 
      error: error.message 
    });
  }
});

// @route   GET /api/analytics/insights
// @desc    Get AI-driven spending insights
// @access  Private
router.get('/insights', protect, async (req, res) => {
  try {
    const now = new Date();
    const currentMonth = now.getMonth();
    const currentYear = now.getFullYear();
    
    const thisMonthExpenses = await Expense.find({
      user: req.user._id,
      date: {
        $gte: new Date(currentYear, currentMonth, 1),
        $lt: new Date(currentYear, currentMonth + 1, 1)
      }
    });
    
    const lastMonthExpenses = await Expense.find({
      user: req.user._id,
      date: {
        $gte: new Date(currentYear, currentMonth - 1, 1),
        $lt: new Date(currentYear, currentMonth, 1)
      }
    });
    
    if (thisMonthExpenses.length === 0 && lastMonthExpenses.length === 0) {
      return res.json({
        insights: [{
          type: 'info',
          message: 'Start tracking expenses to get personalized insights',
          icon: 'üí°'
        }],
        thisMonthTotal: 0,
        lastMonthTotal: 0
      });
    }
    
    const thisMonthTotal = thisMonthExpenses.reduce((sum, e) => sum + e.amount, 0);
    const lastMonthTotal = lastMonthExpenses.reduce((sum, e) => sum + e.amount, 0);
    const change = lastMonthTotal > 0 ? ((thisMonthTotal - lastMonthTotal) / lastMonthTotal * 100).toFixed(1) : 0;
    
    // Find top spending categories
    const categoryTotals = {};
    thisMonthExpenses.forEach(exp => {
      categoryTotals[exp.category] = (categoryTotals[exp.category] || 0) + exp.amount;
    });
    
    const topCategories = Object.entries(categoryTotals)
      .sort((a, b) => b[1] - a[1])
      .slice(0, 3)
      .map(([cat, amount]) => ({ 
        category: cat, 
        amount: parseFloat(amount.toFixed(2)) 
      }));
    
    // Generate insights
    const insights = [];
    
    if (change > 20) {
      insights.push({
        type: 'warning',
        message: `Your spending increased by ${change}% compared to last month`,
        icon: '‚ö†Ô∏è',
        action: 'Consider reviewing your budget limits'
      });
    } else if (change < -20) {
      insights.push({
        type: 'success',
        message: `Great job! You reduced spending by ${Math.abs(change)}% this month`,
        icon: 'üéâ',
        action: 'Keep up the good work!'
      });
    }
    
    if (topCategories.length > 0) {
      insights.push({
        type: 'info',
        message: `Your highest spending category is ${topCategories[0].category} at ${topCategories[0].amount}`,
        icon: 'üìä',
        action: 'Review expenses in this category'
      });
    }
    
    // Day of week analysis
    const dayTotals = { 0: 0, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0 };
    thisMonthExpenses.forEach(exp => {
      const day = new Date(exp.date).getDay();
      dayTotals[day] += exp.amount;
    });
    
    const maxDay = Object.entries(dayTotals).sort((a, b) => b[1] - a[1])[0];
    const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
    
    if (maxDay[1] > 0) {
      insights.push({
        type: 'info',
        message: `You spend most on ${dayNames[maxDay[0]]}s`,
        icon: 'üìÖ',
        action: 'Plan ahead for high-spending days'
      });
    }
    
    // Average transaction analysis
    const avgTransaction = thisMonthTotal / thisMonthExpenses.length;
    if (avgTransaction > 100) {
      insights.push({
        type: 'tip',
        message: `Your average transaction is ${avgTransaction.toFixed(2)}. Consider breaking down large purchases`,
        icon: 'üí°',
        action: 'Track individual items for better control'
      });
    }
    
    // Frequency analysis
    const daysWithExpenses = new Set(thisMonthExpenses.map(e => 
      new Date(e.date).toISOString().substring(0, 10)
    )).size;
    const daysInMonth = new Date(currentYear, currentMonth + 1, 0).getDate();
    const expenseFrequency = (daysWithExpenses / daysInMonth * 100).toFixed(0);
    
    if (expenseFrequency > 50) {
      insights.push({
        type: 'tip',
        message: `You're making expenses on ${expenseFrequency}% of days this month`,
        icon: 'üìà',
        action: 'Consider consolidating purchases to save time'
      });
    }
    
    res.json({
      thisMonthTotal: parseFloat(thisMonthTotal.toFixed(2)),
      lastMonthTotal: parseFloat(lastMonthTotal.toFixed(2)),
      changePercentage: parseFloat(change),
      topCategories,
      insights,
      transactionCount: thisMonthExpenses.length,
      averageTransaction: parseFloat(avgTransaction.toFixed(2)),
      expenseFrequency: parseInt(expenseFrequency)
    });
  } catch (error) {
    console.error('Error generating insights:', error);
    res.status(500).json({ 
      message: 'Error generating insights', 
      error: error.message 
    });
  }
});

// @route   GET /api/analytics/spending-patterns
// @desc    Get spending patterns and habits
// @access  Private
router.get('/spending-patterns', protect, async (req, res) => {
  try {
    const threeMonthsAgo = new Date();
    threeMonthsAgo.setMonth(threeMonthsAgo.getMonth() - 3);
    
    const expenses = await Expense.find({
      user: req.user._id,
      date: { $gte: threeMonthsAgo }
    }).sort({ date: 1 });
    
    if (expenses.length === 0) {
      return res.json({
        message: 'Not enough data to analyze patterns',
        patterns: []
      });
    }
    
    // Time of day patterns (if you store time in date field)
    const hourlySpending = {};
    expenses.forEach(exp => {
      const hour = new Date(exp.date).getHours();
      hourlySpending[hour] = (hourlySpending[hour] || 0) + exp.amount;
    });
    
    // Category patterns
    const categoryFrequency = {};
    expenses.forEach(exp => {
      categoryFrequency[exp.category] = (categoryFrequency[exp.category] || 0) + 1;
    });
    
    const mostFrequentCategory = Object.entries(categoryFrequency)
      .sort((a, b) => b[1] - a[1])[0];
    
    // Weekly patterns
    const weekdaySpending = { 0: 0, 1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0 };
    expenses.forEach(exp => {
      const day = new Date(exp.date).getDay();
      weekdaySpending[day] += exp.amount;
    });
    
    const patterns = [];
    
    patterns.push({
      pattern: 'Most Frequent Category',
      value: mostFrequentCategory ? mostFrequentCategory[0] : 'N/A',
      frequency: mostFrequentCategory ? mostFrequentCategory[1] : 0,
      insight: 'This is where you spend most often'
    });
    
    const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
    const highestSpendingDay = Object.entries(weekdaySpending)
      .sort((a, b) => b[1] - a[1])[0];
    
    patterns.push({
      pattern: 'Highest Spending Day',
      value: dayNames[highestSpendingDay[0]],
      amount: parseFloat(highestSpendingDay[1].toFixed(2)),
      insight: 'Your most expensive day of the week'
    });
    
    res.json({
      patterns,
      totalExpenses: expenses.length,
      dateRange: {
        from: threeMonthsAgo.toISOString().substring(0, 10),
        to: new Date().toISOString().substring(0, 10)
      }
    });
    
  } catch (error) {
    console.error('Error analyzing patterns:', error);
    res.status(500).json({ 
      message: 'Error analyzing patterns', 
      error: error.message 
    });
  }
});

module.exports = router;